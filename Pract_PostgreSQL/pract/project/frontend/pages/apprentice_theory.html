<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/css/stile.css" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/apprentice_theory.js"></script>

    <title> Практика </title>
</head>

<body>
    <header class="header">
        <section>
            <h1 class="header_text" id="header_to_main"> Теория </h1>
        </section>
        <section class="buttons">
            <form>
                <button type="button" class="button" id="out_to_stat"> Назад </button>
            </form>
        </section>
    </header>

    <section class="main_content">
        <section class="main_content_for_pages">
            <div id="theory_content">
                <h3> Синтааксис SQL. Лексическая структура </h3>
                <p>
                    В этой главе описывается синтаксис языка SQL. Тем самым закладывается фундамент для следующих глав, где будет подробно рассмотрено, как с помощью команд SQL описывать и изменять данные.
                </p>
                <p>
                    Мы советуем прочитать эту главу и тем, кто уже знаком SQL, так как в ней описываются несколько правил и концепций, которые реализованы в разных базах данных SQL по-разному или относятся только к PostgreSQL.
                </p>
                <h4>Лексическая структура</h4>
                <p>
                    SQL-программа состоит из последовательности команд. Команда, в свою очередь, представляет собой последовательность компонентов, оканчивающуюся точкой с запятой («;»). Конец входного потока также считается концом команды. Какие именно компоненты допустимы
                    для конкретной команды, зависит от её синтаксиса.
                </p>
                <p>
                    Компонентом команды может быть ключевое слово, идентификатор, идентификатор в кавычках, строка (или константа) или специальный символ. Компоненты обычно разделяются пробельными символами (пробел, табуляция, перевод строки), но это не требуется, если нет
                    неоднозначности (например, когда спецсимвол оказывается рядом с компонентом другого типа).
                </p>
                <p>
                    Например, следующий текст является правильной (синтаксически) SQL-программой: <br>
                    <code>SELECT * FROM MY_TABLE; UPDATE MY_TABLE SET A=5;
                    <br> INTO MY_TABLE VALUES (3, 'hi there');</code>
                </p>
                <p>
                    Это последовательность трёх команд, по одной в строке (хотя их можно было разместить и в одну строку или наоборот, разделить команды на несколько строк).
                </p>
                <p>
                    Кроме этого, SQL-программы могут содержать комментарии. Они не являются компонентами команд, а по сути равносильны пробельным символам.
                </p>
                <p>
                    Синтаксис SQL не очень строго определяет, какие компоненты идентифицируют команды, а какие — их операнды или параметры. Первые несколько компонентов обычно содержат имя команды, так что в данном примере мы можем говорить о командах <code>SELECT</code>,
                    <code>UPDATE</code> и <code>INSERT</code>. Но например, команда <code>UPDATE</code> требует, чтобы также в определённом положении всегда стоял компонент <code>SET</code>, а <code>INSERT</code> в приведённом виде требует наличия компонента
                    <code>VALUES</code>. Точные синтаксические правила для каждой команды описаны в Части VI.
                </p>
                <h4>1. Идентификаторы и ключевые слова</h4>
                <p>
                    Показанные выше команды содержали компоненты <code>SELECT</code>, <code>UPDATE</code> и <code>VALUES</code>, которые являются примерами ключевых слов, то есть слов, имеющих фиксированное значение в языке SQL. Компоненты <code>MY_TABLE</code>                    и
                    <code>A</code> являются примерами идентификаторов. Они идентифицируют имена таблиц, столбцов или других объектов баз данных, в зависимости от того, где они используются. Поэтому иногда их называют просто «именами». Ключевые слова и
                    идентификаторы имеют одинаковую лексическую структуру, то есть, не зная языка, нельзя определить, является ли некоторый компонент ключевым словом или идентификатором. Полный список ключевых слов приведён в Приложении C.
                </p>
                <p>
                    Идентификаторы и ключевые слова SQL должны начинаться с буквы (a-z, хотя допускаются также не латинские буквы и буквы с диакритическими знаками) или подчёркивания (_). Последующими символами в идентификаторе или ключевом слове могут быть буквы, цифры
                    (0-9), знаки доллара ($) или подчёркивания. Заметьте, что строго следуя букве стандарта SQL, знаки доллара нельзя использовать в идентификаторах, так что их использование вредит переносимости приложений. В стандарте SQL гарантированно
                    не будет ключевых слов с цифрами и начинающихся или заканчивающихся подчёркиванием, так что идентификаторы такого вида защищены от возможных конфликтов с будущими расширениями стандарта.
                </p>
                <p>
                    Система выделяет для идентификатора не более <code>NAMEDATALEN</code>-1 байт, а более длинные имена усекаются. По умолчанию <code>NAMEDATALEN</code> равно 64, так что максимальная длина идентификатора равна 63 байтам. Если этого недостаточно,
                    этот предел можно увеличить, изменив константу <code>NAMEDATALEN</code> в файле <code>src/include/pg_config_manual.h</code>.
                </p>
                <p>
                    Ключевые слова и идентификаторы без кавычек воспринимаются системой без учёта регистра. Таким образом: <br>
                    <code>UPDATE MY_TABLE SET A = 5;</code>
                    <br> равносильно записи:
                    <br> <code>uPDaTE my_TabLE SeT a = 5;</code>
                </p>
                <p>
                    Часто используется неформальное соглашение записывать ключевые слова заглавными буквами, а имена строчными, например:
                    <br> <code>UPDATE my_table SET a = 5;</code>
                </p>
                <p>
                    Есть и другой тип идентификаторов: отделённые идентификаторы или идентификаторы в кавычках. Они образуются при заключении обычного набора символов в двойные кавычки ("). Такие идентификаторы всегда будут считаться идентификаторами, но не ключевыми словами.
                    Так "<code>select</code>" можно использовать для обозначения столбца или таблицы «select», тогда как <code>select</code> без кавычек будет воспринят как ключевое слово и приведёт к ошибке разбора команды в месте,
                    где ожидается имя таблицы или столбца. Тот же пример можно переписать с идентификаторами в кавычках следующим образом:
                    <br> <code>UPDATE "my_table" SET "a" = 5;</code>
                </p>
                <p>
                    Идентификаторы в кавычках могут содержать любые символы, за исключением символа с кодом 0 (Чтобы включить в такой идентификатор кавычки, продублируйте их.) Это позволяет создавать таблицы и столбцы с именами, которые иначе были бы невозможны, например,
                    с пробелами или амперсандами. Ограничение длины при этом сохраняется.
                </p>
                <p>
                    Идентификатор, заключённый в кавычки, становится зависимым от регистра, тогда как идентификаторы без кавычек всегда переводятся в нижний регистр. Например, идентификаторы FOO, foo и "foo" считаются одинаковыми в PostgreSQL, но "Foo" и "FOO" отличны друг
                    от друга и от предыдущих трёх. (Приведение имён без кавычек к нижнему регистру, как это делает PostgreSQL, несовместимо со стандартом SQL, который говорит о том, что имена должны приводиться к верхнему регистру. То есть, согласно стандарту
                    foo должно быть эквивалентно "FOO", а не "foo". Поэтому при создании переносимых приложений рекомендуется либо всегда заключать определённое имя в кавычки, либо не заключать никогда.)
                </p>
                <p>
                    Ещё один вариант идентификаторов в кавычках позволяет использовать символы Unicode по их кодам. Такой идентификатор начинается с U& (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт двойная кавычка, например U&"foo". (Заметьте, что
                    при этом возникает неоднозначность с оператором &. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в кавычках можно записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных
                    цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, идентификатор "data" можно записать так:
                    <br> <code>U&"d\0061t\+000061"</code>
                </p>
                <p>
                    В следующем менее тривиальном примере закодировано русское слово «слон», записанное кириллицей:
                    <br> <code>U&"\0441\043B\043E\043D"</code>
                </p>
                <p>
                    Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <code>UESCAPE</code> после строки, например:
                    <br> <code>U&"d!0061t!+000061" UESCAPE '!'</code>
                </p>
                <p>
                    В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки или пробельного символа. Заметьте, что спецсимвол заключается не в двойные кавычки, а в апострофы, после <code>UESCAPE</code>.
                </p>
                <p>
                    Чтобы сделать спецсимволом знак апострофа, напишите его дважды.
                </p>
                <p>
                    Записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF можно либо в четырёх-, либо в шестизначной форме, хотя наличие шестизначной формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно,
                    а объединяются в один символ, который затем кодируется в UTF-8.)
                </p>
                <p>
                    Когда кодировка сервера — не UTF-8, символ с кодом, указанным этой спецпоследовательностью, преобразуется в фактическую кодировку сервера; если такое преобразование невозможно, выдаётся ошибка.
                </p>
                <h4>2. Константы</h4>
                <p>
                    В PostgreSQL есть три типа констант подразумеваемых типов: строки, битовые строки и числа. Константы можно также записывать, указывая типы явно, что позволяет представить их более точно и обработать более эффективно. Эти варианты рассматриваются в следующих
                    подразделах.
                </p>
                <h4>2.1. Строковые константы</h4>
                <p>
                    Строковая константа в SQL — это обычная последовательность символов, заключённая в апострофы ('), например: '### ######'. Чтобы включить апостроф в строку, напишите в ней два апострофа рядом, например: '##### #''###'. Заметьте, это не то же самое, что
                    двойная кавычка (").
                </p>
                <p>
                    Две строковые константы, разделённые пробельными символами и минимум одним переводом строки, объединяются в одну и обрабатываются, как если бы строка была записана в одной константе. Например:
                    <br><code>SELECT 'foo' 'bar';</code>
                    <br> эквивалентно:
                    <br><code>SELECT 'foobar';</code>
                    <br>но эта запись:
                    <br><code>SELECT 'foo'
                        <br>'bar';</code>
                    <br>считается синтаксической ошибкой. (Это несколько странное поведение определено в стандарте SQL, PostgreSQL просто следует ему.)
                </p>
                <h4>2.2. Строковые константы со спецпоследовательностями в стиле C</h4>
                <p>
                    PostgreSQL также принимает «спецпоследовательности», что является расширением стандарта SQL. Строка со спецпоследовательностями начинается с буквы <code>E</code> (заглавной или строчной), стоящей непосредственно перед апострофом, например:
                    <code>E'foo'</code>. (Когда константа спецпоследовательностью разбивается на несколько строк, букву E нужно поставить только перед первым открывающим апострофом.) Внутри таких строк символ обратной косой черты (\) начинает C-подобные
                    спецпоследовательности, в которых сочетание обратной косой черты со следующим символом(ами) даёт определённое байтовое значение, как показано в Таблице 4.1.
                </p>
                <table border="1">
                    <caption>Таблица 4.1. Спецпоследовательности</caption>
                    <thead>
                        <tr>
                            <th>Спецпоследовательность</th>
                            <th>Интерпретация</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>\b</code></td>
                            <td>символ «забой»</td>
                        </tr>
                        <tr>
                            <td><code>\f</code></td>
                            <td>подача формы</td>
                        </tr>
                        <tr>
                            <td><code>\n</code></td>
                            <td>новая строка</td>
                        </tr>
                        <tr>
                            <td><code>\r</code></td>
                            <td>возврат каретки</td>
                        </tr>
                        <tr>
                            <td><code>\t</code></td>
                            <td>табуляция</td>
                        </tr>
                        <tr>
                            <td><code>\o, \oo, \ooo</code> (o = 0–7)</td>
                            <td>восьмеричное значение байта</td>
                        </tr>
                        <tr>
                            <td><code>\xh, \xhh</code> (h = 0–9, A–F)</td>
                            <td>шестнадцатеричное значение байта</td>
                        </tr>
                        <tr>
                            <td><code>\uxxxx, \Uxxxxxxxx</code> (x = 0–9, A–F)</td>
                            <td>16- или 32-битный шестнадцатеричный код символа Unicode</td>
                        </tr>
                    </tbody>
                </table>
                <p>
                    Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (\\). Так же можно включить в строку апостроф, написав \', в дополнение к обычному
                    способу ''.
                </p>
                <p>
                    Вы должны позаботиться, чтобы байтовые последовательности, которые вы таким образом, особенно в восьмеричной и шестнадцатеричной записи, образовывали допустимые символы в серверной кодировке. Также может быть полезно использовать спецпоследовательности
                    Unicode или альтернативную запись, описанную в Подразделе 4.1.2.3; в этом случае сервер будет проверять, возможно ли преобразовать указанный символ.
                </p>
                <div>
                    <h3>Внимание</h3>
                    <p>
                        Если параметр конфигурации standard_conforming_strings имеет значение <code>off</code>, PostgreSQL распознаёт обратную косую черту как спецсимвол и в обычных строках, и в строках со спецпоследовательностями. Однако в версии PostgreSQL
                        9.1 по умолчанию принято значение <code>on</code>, и в этом случае обратная косая черта распознаётся только в спецстроках. Это поведение больше соответствует стандарту, хотя может нарушить работу приложений, рассчитанных на предыдущий
                        режим, когда обратная косая черта распознавалась везде. В качестве временного решения вы можете изменить этот параметр на <code>off</code>, но лучше уйти от такой практики. Если вам нужно, чтобы обратная косая черта представляла
                        специальный символ, задайте строковую константу с <code>E</code>.
                    </p>
                    <p>
                        В дополнение к <code>standard_conforming_strings</code> поведением обратной косой черты в строковых константах управляют параметры escape_string_warning и backslash_quote.
                    </p>
                </div>
                <p>
                    Строковая константа не может включать символ с кодом 0
                </p>
                <h4>2.3. Строковые константы со спецпоследовательностями Unicode</h4>
                <p>
                    PostgreSQL также поддерживает ещё один вариант спецпоследовательностей, позволяющий включать в строки символы Unicode по их кодам. Строковая константа со спецпоследовательностями Unicode начинается с U& (строчная или заглавная U и амперсанд), а затем
                    сразу без пробелов идёт апостроф, например <code>U&'foo'</code>. (Заметьте, что при этом возникает неоднозначность с оператором &. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в апострофах можно
                    записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, строку '<code>data</code>'
                    можно записать так:
                    <br><code>U&'d\0061t\+000061'</code>
                </p>
                <p>
                    В следующем менее тривиальном примере закодировано русское слово «слон», записанное кириллицей:
                    <br><code>U&'\0441\043B\043E\043D'</code>
                </p>
                <p>
                    Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <code>UESCAPE</code>после строки, например:
                    <br><code>U&'d!0061t!+000061' UESCAPE '!'</code>
                </p>
                <p>
                    Чтобы включить спецсимвол в строку буквально, напишите его дважды.
                </p>
                <p>
                    Записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF можно либо в четырёх-, либо в шестизначной форме, хотя наличие шестизначной формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно,
                    а объединяются в один символ, который затем кодируется в UTF-8.)
                </p>
                <p>
                    Когда кодировка сервера — не UTF-8, символ с кодом, указанным этой спецпоследовательностью, преобразуется в фактическую кодировку сервера; если такое преобразование невозможно, выдаётся ошибка.
                </p>
                <p>
                    Также заметьте, что спецпоследовательности Unicode в строковых константах работают, только когда параметр конфигурации standard_conforming_strings равен on. Это объясняется тем, что иначе клиентские программы, проверяющие SQL-операторы, можно будет ввести
                    в заблуждение и эксплуатировать это как уязвимость, например, для SQL-инъекций. Если этот параметр имеет значение off, эти спецпоследовательности будут вызывать ошибку.
                </p>
                <h4>2.4. Строковые константы, заключённые в доллары</h4>
                <p>
                    Хотя стандартный синтаксис для строковых констант обычно достаточно удобен, он может плохо читаться, когда строка содержит много апострофов или обратных косых черт, так как каждый такой символ приходится дублировать. Чтобы и в таких случаях запросы оставались
                    читаемыми, PostgreSQL предлагает ещё один способ записи строковых констант — «заключение строк в доллары». Строковая константа, заключённая в доллары, начинается со знака доллара ($), необязательного «тега» из нескольких символов и
                    ещё одного знака доллара, затем содержит обычную последовательность символов, составляющую строку, и оканчивается знаком доллара, тем же тегом и замыкающим знаком доллара. Например, строку «Жанна д'Арк» можно записать в долларах двумя
                    способами:
                    <br><code>$$##### #'###$$
                    <br>$SomeTag$##### #'###$SomeTag$</code>
                </p>
                <p>
                    Заметьте, что внутри такой строки апострофы не нужно записывать особым образом. На самом деле, в строке, заключённой в доллары, все символы можно записывать в чистом виде: содержимое строки всегда записывается буквально. Ни обратная косая черта, ни даже
                    знак доллара не являются спецсимволами, если только они не образуют последовательность, соответствующую открывающему тегу.
                </p>
                <p>
                    Строковые константы в долларах можно вкладывать друг в друга, выбирая на разных уровнях вложенности разные теги. Чаще всего это используется при написании определений функций. Например:
                    <br><code>$function$
                    <br>BEGIN
                    <br>     RETURN ($1 ~ $q$[\t\r\n\v\\]$q$)
                    <br>END;
                    <br>$function$</code>
                </p>
                <p>
                    Здесь последовательность <code>$q$[\t\r\n\v\\]$q$</code> представляет в долларах текстовую строку <code>[\t\r \n\v\\]</code>, которая будет обработана, когда PostgreSQL будет выполнять эту функцию. Но так как эта последовательность
                    не соответствует внешнему тегу в долларах (<code>$function$</code>), с точки зрения внешней строки это просто обычные символы внутри константы.
                </p>
                <p>
                    Тег строки в долларах, если он присутствует, должен соответствовать правилам, определённым для идентификаторов без кавычек, и к тому же не должен содержать знак доллара. Теги регистрозависимы, так что <code>$tag$String content$tag$</code>                    — правильная строка, а <code>$TAG$String</code>
                    <code>content$tag$</code> — нет.
                </p>
                <p>
                    Строка в долларах, следующая за ключевым словом или идентификатором, должна отделяться от него пробельными символами, иначе доллар будет считаться продолжением предыдущего идентификатора.
                </p>
                <p>
                    Заключение строк в доллары не является частью стандарта SQL, но часто это более удобный способ записывать сложные строки, чем стандартный вариант с апострофами. Он особенно полезен, когда нужно представить строковую константу внутри другой строки, что
                    часто требуется в определениях процедурных функций. Ограничившись только апострофами, каждую обратную косую черту в приведённом примере пришлось бы записывать четырьмя такими символами, которые бы затем уменьшились до двух при разборе
                    внешней строки, и наконец до одного при обработке внутренней строки во время выполнения функции.
                </p>
                <h4>2.5. Битовые строковые константы</h4>
                <p>
                    Битовые строковые константы похожи на обычные с дополнительной буквой B (заглавной или строчной), добавленной непосредственно перед открывающим апострофом (без промежуточных пробелов), например: <code>B'1001'</code>. В битовых строковых
                    константах допускаются лишь символы 0 и 1
                </p>
                <p>
                    Битовые константы могут быть записаны и по-другому, в шестнадцатеричном виде, с начальной буквой X (заглавной или строчной), например: <code>X'1FF'</code>. Такая запись эквивалентна двоичной, только четыре двоичных цифры заменяются
                    одной шестнадцатеричной.
                </p>
                <p>
                    Обе формы записи допускают перенос строк так же, как и обычные строковые константы. Однако заключать в доллары битовые строки нельзя.
                </p>
                <h4>2.6. Числовые константы</h4>
                <p>
                    Числовые константы могут быть заданы в следующем общем виде:
                    <br><code>#####
                    <br>#####.[#####][e[+-]#####]
                    <br>[#####].#####[e[+-]#####]
                    <br>#####e[+-]#####</code>
                    <br>где <code>#####</code> — это одна или несколько десятичных цифр (0..9). До или после десятичной точки (при её наличии) должна быть минимум одна цифра. Как минимум одна цифра должна следовать за обозначением экспоненты (e), если
                    оно присутствует. В числовой константе не может быть пробелов или других символов. Заметьте, что любой знак минус или плюс в начале строки не считается частью числа; это оператор, применённый к константе.
                </p>
                <p>
                    Несколько примеров допустимых числовых констант:
                    <br>42
                    <br>3.5
                    <br>4.
                    <br>.001
                    <br>5e1
                    <br>1.925e-3
                </p>
                <p>
                    Числовая константа, не содержащая точки и экспоненты, изначально рассматривается как константа типа <code>integer</code>, если её значение умещается в 32-битный тип <code>integer</code>; затем как константа типа <code>bigint</code>,
                    если её значение умещается в 64-битный
                    <code>bigint</code>; в противном случае она принимает тип <code>numeric</code>. Константы, содержащие десятичные точки и/или экспоненты, всегда считаются константами типа <code>numeric</code>.
                </p>
                <p>
                    Изначально назначенный тип данных числовой константы это только отправная точка для алгоритмов определения типа. В большинстве случаев константа будет автоматически приведена к наиболее подходящему типу для данного контекста. При необходимости вы можете
                    принудительно интерпретировать числовое значение как значение определённого типа, приведя его тип к нужному. Например, вы можете сделать, чтобы числовое значение рассматривалось как имеющее тип <code>real</code>                    (<code>float4</code>), написав:
                    <br><code>REAL '1.23' -- ######### #####
                    <br>1.23::REAL -- ##### PostgreSQL (############)</code>
                </p>
                <p>
                    На самом деле это только частные случаи синтаксиса приведения типов, который будет рассматриваться далее.
                </p>
                <h4>2.7. Константы других типов</h4>
                <p>
                    Константу обычного типа можно ввести одним из следующих способов:
                    <br><code>type 'string'
                    <br>'string'::type
                    <br>CAST ( 'string' AS type )</code>
                </p>
                <p>
                    Текст строковой константы передаётся процедуре преобразования ввода для типа, обозначенного здесь <code>type</code>. Результатом становится константа указанного типа. Явное приведение типа можно опустить, если нужный тип константы
                    определяется однозначно (например, когда она присваивается непосредственно столбцу таблицы), так как в этом случае приведение происходит автоматически.
                </p>
                <p>
                    Строковую константу можно записать, используя как обычный синтаксис SQL, так и формат с долларами.
                </p>
                <p>
                    Также можно записать приведение типов, используя синтаксис функций:
                    <br><code>typename ( 'string' )</code>
                    <br>но это работает не для всех имён типов; подробнее об этом написано в Подразделе 4.2.9.
                </p>
                <p>
                    Конструкцию <code>::, CAST()</code> и синтаксис вызова функции можно также использовать для преобразования типов обычных выражений во время выполнения, как описано в Подразделе 4.2.9. Во избежание синтаксической неопределённости, запись
                    <code>### '######'</code> можно использовать только для указания типа простой текстовой константы. Ещё одно ограничение записи <code>### '######'</code>: она не работает для массивов; для таких констант следует использовать <code>::</code>                    или <code>CAST()</code>.
                </p>
                <p>
                    Синтаксис <code>CAST()</code> соответствует SQL, а запись <code>type 'string'</code> является обобщением стандарта: в SQL такой синтаксис поддерживает только некоторые типы данных, но PostgreSQL позволяет использовать его для всех.
                    Синтаксис с :: имеет исторические корни в PostgreSQL, как и запись в виде вызова функции.</p>
                </p>
                <h4>3. Операторы</h4>
                <p>
                    Имя оператора образует последовательность не более чем <code>NAMEDATALEN</code>-1 (по умолчанию 63) символов из следующего списка:
                    <br><code>+ - * / &#60; > = ~ ! @ # % ^ & | ` ?</code>
                </p>
                <p>
                    Однако для имён операторов есть ещё несколько ограничений:
                </p>
                <ul>
                    <li>Сочетания символов -- и /* не могут присутствовать в имени оператора, так как они будут обозначать начало комментария.</li>
                    <li>
                        Многосимвольное имя оператора не может заканчиваться знаком + или -, если только оно не содержит также один из этих символов:
                        <br><code>~ ! @ # % ^ & | ` ?</code>
                        <br>Например, @- — допустимое имя оператора, а *- — нет. Благодаря этому ограничению, PostgreSQL может разбирать корректные SQL-запросы без пробелов между компонентами.
                    </li>
                </ul>
                <p>
                    Записывая нестандартные SQL-операторы, обычно нужно отделять имена соседних операторов пробелами для однозначности. Например, если вы определили левый унарный оператор с именем @, вы не можете написать <code>X*@Y</code>, а должны написать
                    <code>X* @Y</code>, чтобы PostgreSQL однозначно прочитал это как два оператора, а не один.
                </p>
                <h4>4. Специальные знаки</h4>
                <p>
                    Некоторые не алфавитно-цифровые символы имеют специальное значение, но при этом не являются операторами. Подробнее их использование будет рассмотрено при описании соответствующего элемента синтаксиса. Здесь они упоминаются только для сведения и обобщения
                    их предназначения.
                </p>
                <ul>
                    <li>Знак доллара ($), предваряющий число, используется для представления позиционного параметра в теле определения функции или подготовленного оператора. В других контекстах знак доллара может быть частью идентификатора или строковой константы,
                        заключённой в доллары.
                    </li>
                    <li>
                        Круглые скобки (()) имеют обычное значение и применяются для группировки выражений и повышения приоритета операций. В некоторых случаях скобки — это необходимая часть синтаксиса определённых SQL-команд.
                    </li>
                    <li>
                        Квадратные скобки ([]) применяются для выделения элементов массива. Подробнее массивы рассматриваются в Разделе 8.15.
                    </li>
                    <li>
                        Запятые (,) используются в некоторых синтаксических конструкциях для разделения элементов списка.
                    </li>
                    <li>
                        Точка с запятой (;) завершает команду SQL. Она не может находиться нигде внутри команды, за исключением строковых констант или идентификаторов в кавычках.
                    </li>
                    <li>
                        Двоеточие (:) применяется для выборки «срезов» массивов (см. Раздел 8.15.) В некоторых диалектах SQL (например, в Embedded SQL) двоеточие может быть префиксом в имени переменной.
                    </li>
                    <li>
                        Звёздочка (*) используется в некоторых контекстах как обозначение всех полей строки или составного значения. Она также имеет специальное значение, когда используется как аргумент некоторых агрегатных функций, а именно функций, которым не нужны явные параметры.
                    </li>
                    <li>
                        Точка (.) используется в числовых константах, а также для отделения имён схемы, таблицы и столбца.
                    </li>
                </ul>
                <h4>5. Комментарии</h4>
                <p>
                    Комментарий — это последовательность символов, которая начинается с двух минусов и продолжается до конца строки, например:
                    <br><code>-- ### ########### ########### SQL</code>
                </p>
                <p>
                    Кроме этого, блочные комментарии можно записывать в стиле C:
                    <br><code>/* ############# ###########
                    <br>* # ############: /* ######### #### ########### */
                    <br>*/</code>
                    <br>где комментарий начинается с /* и продолжается до соответствующего вхождения */. Блочные комментарии можно вкладывать друг в друга, как разрешено по стандарту SQL (но не разрешено в C), так что вы можете комментировать большие
                    блоки кода, которые при этом уже могут содержать блоки комментариев.
                </p>
                <p>
                    Комментарий удаляется из входного потока в начале синтаксического анализа и фактически заменяется пробелом.
                </p>
                <h4>6. Приоритеты операторов</h4>
                <p>
                    В Таблице 4.2 показаны приоритеты и очерёдность операторов, действующие в PostgreSQL. Большинство операторов имеют одинаковый приоритет и вычисляются слева направо. Приоритет и очерёдность операторов жёстко фиксированы в синтаксическом анализаторе. Если
                    вы хотите, чтобы выражение с несколькими операторами разбиралось не в том порядке, который диктуют эти приоритеты, добавьте скобки.
                </p>
                <table border="1">
                    <caption>Таблица 4.1. Спецпоследовательности</caption>
                    <thead>
                        <tr>
                            <th>Оператор/элемент</th>
                            <th>Очерёдность</th>
                            <th>Описание</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>.</code></td>
                            <td>слева-направо</td>
                            <td>разделитель имён таблицы и столбца</td>
                        </tr>
                        <tr>
                            <td><code>::</code></td>
                            <td>слева-направо</td>
                            <td>приведение типов в стиле PostgreSQL</td>
                        </tr>
                        <tr>
                            <td><code>::</code></td>
                            <td>слева-направо</td>
                            <td>приведение типов в стиле PostgreSQL</td>
                        </tr>
                        <tr>
                            <td><code>[ ]</code></td>
                            <td>слева-направо</td>
                            <td>выбор элемента массива</td>
                        </tr>
                        <tr>
                            <td><code>+ -</code></td>
                            <td>слева-направо</td>
                            <td>унарный плюс, унарный минус</td>
                        </tr>
                        <tr>
                            <td><code>^</code></td>
                            <td>слева-направо</td>
                            <td>возведение в степень</td>
                        </tr>
                        <tr>
                            <td><code>* / %</code></td>
                            <td>слева-направо</td>
                            <td>умножение, деление, остаток от деления</td>
                        </tr>
                        <tr>
                            <td><code>+ -</code></td>
                            <td>слева-направо</td>
                            <td>сложение, вычитание</td>
                        </tr>
                        <tr>
                            <td><code>(любой другой оператор)</code></td>
                            <td>слева-направо</td>
                            <td>все другие встроенные и пользовательские операторы</td>
                        </tr>
                        <tr>
                            <td><code>BETWEEN IN LIKE ILIKE SIMILAR</code></td>
                            <td></td>
                            <td>проверка диапазона, проверка членства, сравнение строк</td>
                        </tr>
                        <tr>
                            <td><code>&#60; > = &#60;= >= &#60;></code></td>
                            <td></td>
                            <td>операторы сравнения</td>
                        </tr>
                        <tr>
                            <td><code>IS ISNULL NOTNULL</code></td>
                            <td></td>
                            <td><code>IS TRUE, IS FALSE, IS NULL, IS DISTINCT FROM</code> и т. д.</td>
                        </tr>
                        <tr>
                            <td><code>NOT</code></td>
                            <td>справа-налево</td>
                            <td>логическое отрицание</td>
                        </tr>
                        <tr>
                            <td><code>AND</code></td>
                            <td>слева-направо</td>
                            <td>логическая конъюнкция</td>
                        </tr>
                        <tr>
                            <td><code>OR</code></td>
                            <td>слева-направо</td>
                            <td>логическая дизъюнкция</td>
                        </tr>
                    </tbody>
                </table>
                <p>
                    Заметьте, что правила приоритета операторов также применяются к операторам, определённым пользователем с теми же именами, что и вышеперечисленные встроенные операторы. Например, если вы определите оператор «+» для некоторого нестандартного типа данных,
                    он будет иметь же приоритет, что и встроенный оператор «+», независимо от того, что он у вас делает.
                </p>
                <p>
                    Когда в конструкции <code>OPERATOR</code> используется имя оператора со схемой, например так:
                    <br><code>SELECT 3 OPERATOR(pg_catalog.+) 4;
                    <br>тогда OPERATOR</code>
                    <br>имеет приоритет по умолчанию, соответствующий в Таблице 4.2 строке «любой другой оператор». Это не зависит от того, какие именно операторы находятся в конструкции <code>OPERATOR()</code>.
                </p>
                <div>
                    <h3>Примечание</h3>
                    <p>
                        В PostgreSQL до версии 9.5 действовали немного другие правила приоритета операторов. В частности, операторы &#60;=,>= и &#60;> обрабатывались по общему правилу; проверки IS имели более высокий приоритет; а NOT BETWEEN и связанные конструкции работали
                        несогласованно — в некоторых случаях приоритетнее оказывался оператор NOT, а не BETWEEN. Эти правила были изменены для лучшего соответствия стандарту SQL и для уменьшения путаницы из-за несогласованной обработки логически равнозначных
                        конструкций. В большинстве случаев эти изменения никак не проявятся, либо могут привести к ошибкам типа «нет такого оператора», которые можно разрешить, добавив скобки. Однако, возможны особые случаи, когда запрос будет разобран
                        без ошибки, но его поведение может измениться. Если вас беспокоит, не нарушают ли эти изменения незаметно работу вашего приложения, вы можете проверить это, включив конфигурационный параметр operator_precedence_warning и пронаблюдав,
                        не появятся ли предупреждения в журнале.
                    </p>
                </div>
            </div>
        </section>
        <section class="kontr">
            <div id="div_of_kontr_quest">
                <h3> Контрольные вопросы </h3>

            </div>
        </section>
    </section>
</body>

</html>