#ifndef TYPES_H
#define TYPES_H

#include <cinttypes>
#include <vector>
#include <string>
#include <functional>
#include <map>


using address = uint16_t;    // адрес памяти

using addressReg = uint8_t;  // номер адресного регистра

using MemoryData = uint32_t; // значение из памяти


using byte = uint8_t;		// для сокращения записи



struct Command_struct // структура команды процессора
{
    uint8_t opcode;         // Код операции
    addressReg r1;          // Первый номер регистра (хранит адрес результата выполненной операции)
    addressReg r2;          // Второй номер регистра
    addressReg r3;          // Третий номер регистра
};


struct Address_struct // структура команды загрузки адресного регистра
{
    uint8_t opcode;         // Код операции
    uint8_t r1;             // Номер загружаемого регистра
    address addr;           // Адрес, который будет загружен в регистр
};


union CommandType // типы доступных команд
{
    Command_struct cmdU;    // Обычная команда
    Address_struct cmdAR;   // Команда загрузки адресного регистра
    byte b[4];           // слово 4 байта
};


union DataType // используемые типы данных
{
    uint32_t uintEl;        // Целое беззнаковое число
    int32_t intEl;          // Целое знаковое число
    float flEl;             // Знаковое дробное число
    CommandType anyCommand; // Команда любого вида
    address addr;           // Адрес 16 бит
    byte b[4];           // слово 4 байта
};

/* коды операций */
enum opcode
{
    /* Команда остановки */
    stop = 0,

    /* Команды ввода-вывода */

    iio = 1,         // Ввод-вывод целого числа (ввод: r1-0, вывод: r1-1)
    fio = 2,         // Ввод-вывод вещественного числа (ввод: r1-0, вывод: r1-1)
    regio = 3,       // Ввод-вывод числа из регистра

    /* Команды загрузки и сохранения адресного регистра */
    load = 4,        // Загрузка адресного регистра
    save = 5,        // Сохранение адресного регистра в память
    swap = 6,       // Обмен значениями адресных регистров (r1-1), копирование адресных регистров (r1-0)
    mov = 7,         // Пересылка память-регистр

    /* Команды целочисленной арифметики */
    addI = 8,        // Сложение
    subI = 9,        // Вычитание
    multI = 10,      // Умножение
    divI = 11,       // Деление

    /* Команды дробной арифметики */
    addF = 12,       // Сложение
    SubF = 13,       // Вычитание
    multF = 14,      // Умножение
    divF = 15,       // Деление

    /* Команды адресной арифметики */
    addSh = 16,      // Сложение адресов
    subSh = 17,      // Вычитание адресов
    addShNum = 18,   // Сложение адреса и смещения
    subShNum = 19,   // Вычитания адреса и смещения

    /* Команды перехода */
    call = 20,    // Переход к подпрограмме
    ret = 21,  // Возврат из подпрограммы

    /* Команда безусловного перехода */
    uncondjump = 22,

    /* Команды условного перехода*/
    zfjump = 23,     // Переход с проверка флага нуля
    NOTzfjump = 24,  // Переход с проверкой инвертированного флага нуля
    sfjump = 25,     // Переход с проверка знакового флага
    NOTsfjump = 26,  // Переход с проверкой инвертированного флага знака

    nop = 27         // пустая команда
};



const std::string LC_Symbol = "$"; // символ счетчика размещения

/* префиксы загрузчика */
enum prefix : char
{
    Integer = 'i',      // Целое
    Real = 'f',         // Дробное
    Com = ';',      // Комментарий
    EndPr = 'e',          // Адрес старта программы
    LoadAddress ='a',   // Установка адреса программы
    Cmd = 'c',          // Команда
    Initreg = 'r'       // Загрузка адресного регистра
};




enum priority: int8_t
{
    Uno = 3,    // унарная операция
    High = 2,   //Высокий
    Mid =  1,   //Средний
    Low = 0,    //Низкий
    NOop = -1   //Не операция
};


//====Перечисления для конечного автомата
//Состояния
enum state: uint8_t       //9  состояний
{
    Start,          // стартовое состояние
    LabelOrOper,    // пока не знаем, метка или операция
    Label,          // ввод метки
    WaitingOperations,       // ожидание кода операции
    CodeOperations,           // ввод кода операции
    Arg,            // ввод аргумента
    End,            // конечное состояние

    Ssize
};
//Сигналы
enum typechar: uint8_t//7 сигналов
{
    Blank,      // Пробелы
    Colon,      // Двоеточия
    Comment,    // Комментарии
    Digit,      // Цифры
    Id,         // Идентификаторы
    Underline,  // Подчеркивания
    Other,      // любой символ

    TCsize
};


enum error: uint8_t
{
    noError = 0,

    illSymbol,          // недопустимый символ в одном из полей
    noColon,            // нет двоеточия после метки

    illInteger,         // ошибка в целом числе
    illFloat,           // ошибка в вещественном числе
    illExpression,      // неверный синтаксис арифметики
    undLabel,           // неизвестное имя в выражении

    reuseLabel,         // повторно определенная метка
    illLabel,           // использование зарезервированного слова (операции) в качестве метки
    illCountArgument,   // неправильное количество аргументов
    illOperation,       // недопустимый код операции
    noLabel,            // нет метки в equ, proc
    noEnd               // нет директивы end
};
                                        //(возможно использовать string_view вместо char[] нужен C++17)
/*Оператор*/
struct Operator
{
    bool work = true;                   // подлежит ли обработке
    address lc = 0;                     // смещение - счетчик размещения
    std::vector<byte> binary;           // двоичная команда
    uint16_t number = 0;                // номер исходной строки
    std::string label;                  // метка оператора
    std::string code;                   // код операции или директивы
    std::vector<std::string> arguments; // поле аргументов
    std::string comment;                // комметарий (для листинга)
    error err = error::noError;      // номер ошибки
};

using context = std::map<std::string, uint32_t>; // таблица меток
struct Handle
{
    using function = std::function<void(Operator&, context&)>;
    function func;      // транслирующая функция
    byte code = nop;    // у директив = 0
    uint8_t arg_size = 0;
    bool work = true;
};

#endif // TYPES_H
